diff -uNr gdm-3.30.2-ori/daemon/gdm-local-display-factory.c gdm-3.30.2/daemon/gdm-local-display-factory.c
--- gdm-3.30.2-ori/daemon/gdm-local-display-factory.c	2018-12-26 16:17:55.464421634 +0800
+++ gdm-3.30.2/daemon/gdm-local-display-factory.c	2018-12-27 09:40:56.152505146 +0800
@@ -56,6 +56,7 @@
         GdmDBusLocalDisplayFactory *skeleton;
         GDBusConnection *connection;
         GHashTable      *used_display_numbers;
+        GHashTable      *seat_proxies;
 
         /* FIXME: this needs to be per seat? */
         guint            num_failures;
@@ -88,6 +89,11 @@
                                                          GdmLocalDisplayFactory      *factory);
 
 static gboolean gdm_local_display_factory_sync_seats    (GdmLocalDisplayFactory *factory);
+static GDBusProxy *create_seat_proxy (GdmLocalDisplayFactory *self,
+                                      const char             *seat_id,
+                                      const char             *seat_path);
+
+static gboolean seat_proxy_can_graphical (GDBusProxy *seat_proxy);
 static gpointer local_display_factory_object = NULL;
 static gboolean lookup_by_session_id (const char *id,
                                       GdmDisplay *display,
@@ -520,7 +526,7 @@
         GVariant *result;
         GVariant *array;
         GVariantIter iter;
-        const char *seat;
+        const char *seat, *path;
 
         g_debug ("GdmLocalDisplayFactory: enumerating seats from logind");
         result = g_dbus_connection_call_sync (factory->priv->connection,
@@ -543,8 +549,9 @@
         array = g_variant_get_child_value (result, 0);
         g_variant_iter_init (&iter, array);
 
-        while (g_variant_iter_loop (&iter, "(&so)", &seat, NULL)) {
+        while (g_variant_iter_loop (&iter, "(&s&o)", &seat, &path)) {
                 gboolean is_initial;
+                g_autoptr (GDBusProxy) proxy = NULL;
                 const char *session_type = NULL;
 
                 if (g_strcmp0 (seat, "seat0") == 0) {
@@ -554,6 +561,14 @@
                 } else {
                         is_initial = FALSE;
                 }
+                proxy = create_seat_proxy (factory, seat, path);
+
+                if (!seat_proxy_can_graphical (proxy)) {
+                        g_debug ("GdmLocalDisplayFactory: seat %s not ready for graphical displays", seat);
+                        continue;
+                } else {
+                        g_debug ("GdmLocalDisplayFactory: seat %s ready for graphical displays", seat);
+                }
 
                 create_display (factory, seat, session_type, is_initial);
         }
@@ -564,6 +579,115 @@
 }
 
 static void
+on_seat_proxy_properties_changed (GDBusProxy  *proxy,
+                                  GVariant    *changed_properties,
+                                  char       **invalidated_properties,
+                                  gpointer     user_data)
+{
+        GdmLocalDisplayFactory *factory = GDM_LOCAL_DISPLAY_FACTORY (user_data);
+        g_autoptr (GVariant) value = NULL;
+        const char *seat;
+
+        value = g_variant_lookup_value (changed_properties, "CanGraphical", G_VARIANT_TYPE_BOOLEAN);
+
+        if (!value)
+                return;
+
+        g_debug ("GdmLocalDisplayFactory: CanGraphical changed");
+
+        seat = g_object_get_data (G_OBJECT (proxy), "seat-id");
+
+        if (!seat)
+                return;
+
+        if (g_variant_get_boolean (value)) {
+                gboolean is_initial;
+                const char *session_type = NULL;
+
+                g_debug ("GdmLocalDisplayFactory: seat '%s' now graphical", seat);
+
+                if (g_strcmp0 (seat, "seat0") == 0) {
+                        is_initial = TRUE;
+                        if (gdm_local_display_factory_use_wayland ())
+                                session_type = "wayland";
+                } else {
+                        is_initial = FALSE;
+                }
+
+                create_display (factory, seat, session_type, is_initial);
+        } else {
+                g_debug ("GdmLocalDisplayFactory: seat '%s' no longer graphical", seat);
+                delete_display (factory, seat);
+        }
+}
+
+static GDBusProxy *
+create_seat_proxy (GdmLocalDisplayFactory *self,
+                   const char             *seat,
+                   const char             *path)
+{
+        g_autoptr (GDBusProxy) proxy = NULL;
+        g_autoptr (GError) error = NULL;
+
+        g_debug ("GdmLocalDisplayFactory: creating seat proxy for seat '%s' with path '%s'",
+                 seat, path);
+
+        proxy = G_DBUS_PROXY (g_hash_table_lookup (self->priv->seat_proxies, seat));
+
+        if (proxy != NULL) {
+                g_debug ("GdmLocalDisplayFactory: we already had one, re-using that");
+                return g_object_ref (g_steal_pointer (&proxy));
+        }
+
+        proxy = g_dbus_proxy_new_sync (self->priv->connection,
+                                       G_DBUS_PROXY_FLAGS_NONE,
+                                       NULL,
+                                       "org.freedesktop.login1",
+                                       path,
+                                       "org.freedesktop.login1.Seat",
+                                       NULL,
+                                       &error);
+
+        if (proxy == NULL) {
+                g_debug ("GdmLocalDisplayFactory: failed to get proxy to seat '%s' from logind: %s",
+                         seat, error->message);
+                return NULL;
+        }
+
+        g_hash_table_insert (self->priv->seat_proxies, g_strdup (seat), g_object_ref (proxy));
+        g_object_set_data_full (G_OBJECT (proxy), "seat-id", g_strdup (seat), (GDestroyNotify) g_free);
+        g_signal_connect_object (G_OBJECT (proxy),
+                                 "g-properties-changed",
+                                 G_CALLBACK (on_seat_proxy_properties_changed),
+                                 self,
+                                 0);
+
+        return g_steal_pointer (&proxy);
+}
+
+static gboolean
+seat_proxy_can_graphical (GDBusProxy *seat_proxy)
+{
+        g_autoptr (GVariant) can_graphical = NULL;
+
+        if (seat_proxy == NULL) {
+                g_critical ("GdmLocalDisplayFactory: couldn't create seat proxy, can't find out if it can support graphical sessions");
+                return FALSE;
+        }
+
+        can_graphical = g_dbus_proxy_get_cached_property (seat_proxy, "CanGraphical");
+
+        if (can_graphical == NULL) {
+                g_debug ("GdmLocalDisplayFactory: can't read CanGraphical property for '%s'",
+                         g_dbus_proxy_get_object_path (seat_proxy));
+                return FALSE;
+        }
+
+        return g_variant_get_boolean (can_graphical);
+}
+
+
+static void
 on_seat_new (GDBusConnection *connection,
              const gchar     *sender_name,
              const gchar     *object_path,
@@ -572,10 +696,24 @@
              GVariant        *parameters,
              gpointer         user_data)
 {
-        const char *seat;
+        GdmLocalDisplayFactory *factory = GDM_LOCAL_DISPLAY_FACTORY (user_data);
+        g_autoptr (GDBusProxy) proxy = NULL;
+        const char *seat, *path;
+
+        g_variant_get (parameters, "(&s&o)", &seat, &path);
+        g_debug ("GdmLocalDisplayFactory: new seat '%s' available", seat);
+
+        proxy = create_seat_proxy (factory, seat, path);
+
+        if (!seat_proxy_can_graphical (proxy)) {
+                g_debug ("GdmLocalDisplayFactory: but not yet ready for graphical displays");
+                return;
+        } else {
+                g_debug ("GdmLocalDisplayFactory: which is ready for graphical displays");
+        }
+
+        create_display (factory, seat, NULL, FALSE);
 
-        g_variant_get (parameters, "(&s&o)", &seat, NULL);
-        create_display (GDM_LOCAL_DISPLAY_FACTORY (user_data), seat, NULL, FALSE);
 }
 
 static void
@@ -587,10 +725,15 @@
                  GVariant        *parameters,
                  gpointer         user_data)
 {
-        const char *seat;
+        GdmLocalDisplayFactory *factory = GDM_LOCAL_DISPLAY_FACTORY (user_data);
+        g_autoptr (GDBusProxy) proxy = NULL;
+        const char *seat, *path;
 
         g_variant_get (parameters, "(&s&o)", &seat, NULL);
-        delete_display (GDM_LOCAL_DISPLAY_FACTORY (user_data), seat);
+        g_debug ("GdmLocalDisplayFactory: seat '%s' no longer available", seat);
+
+        g_hash_table_remove (factory->priv->seat_proxies, (gpointer) seat);
+        delete_display (factory, seat);
 }
 
 static gboolean
@@ -668,6 +811,9 @@
         g_autofree char *tty_of_active_vt = NULL;
         g_autofree char *login_session_id = NULL;
         g_autofree char *active_session_id = NULL;
+        gpointer proxy = NULL;
+        g_autoptr (GDBusProxy) seat_proxy = NULL;
+        g_autoptr (GVariant) can_graphical = NULL;
         const char *session_type = NULL;
         int ret;
 
@@ -763,6 +909,19 @@
                 g_debug ("GdmLocalDisplayFactory: active VT is not initial VT, so ignoring");
                 return G_SOURCE_CONTINUE;
         }
+        proxy = g_hash_table_lookup (factory->priv->seat_proxies, "seat0");
+
+        if (proxy == NULL) {
+                g_critical ("GdmLocalDisplayFactory: could not find a proxy for 'seat0'");
+                return G_SOURCE_CONTINUE;
+        }
+
+        seat_proxy = G_DBUS_PROXY (proxy);
+
+        if (!seat_proxy_can_graphical (seat_proxy)) {
+                g_debug ("GdmLocalDisplayFactory: seat0 not yet ready for graphical displays");
+                return G_SOURCE_CONTINUE;
+        }
 
         if (gdm_local_display_factory_use_wayland ())
                 session_type = "wayland";
@@ -1041,6 +1200,7 @@
         factory->priv = GDM_LOCAL_DISPLAY_FACTORY_GET_PRIVATE (factory);
 
         factory->priv->used_display_numbers = g_hash_table_new (NULL, NULL);
+        factory->priv->seat_proxies = g_hash_table_new_full (NULL, NULL, g_free, g_object_unref);
 }
 
 static void
@@ -1055,6 +1215,8 @@
 
         g_return_if_fail (factory->priv != NULL);
 
+        g_hash_table_destroy (factory->priv->seat_proxies);
+
         g_clear_object (&factory->priv->connection);
         g_clear_object (&factory->priv->skeleton);
 
